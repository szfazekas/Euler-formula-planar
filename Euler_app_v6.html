<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Planar Graph Editor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        canvas {
            cursor: crosshair;
            touch-action: none; /* Prevents default touch actions like scrolling */
        }
        .stat-card {
            transition: all 0.3s ease;
            cursor: pointer;
        }
        .stat-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        .stat-card.active {
            transform: translateY(-2px);
            box-shadow: 0 0 0 3px #4f46e5; /* indigo-600 */
        }
        /* Toggle Switch CSS */
        .toggle-checkbox:checked {
            right: 0;
            border-color: #4f46e5; /* indigo-600 */
        }
        .toggle-checkbox:checked + .toggle-label {
            background-color: #4f46e5; /* indigo-600 */
        }
        /* Tooltip */
        #tooltip {
            pointer-events: none;
            z-index: 100;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 flex flex-col md:flex-row h-screen overflow-hidden">

    <!-- Main Content -->
    <main class="flex-1 flex flex-col p-4 md:p-6">
        <div class="flex-1 bg-white rounded-xl shadow-lg border border-gray-200">
            <canvas id="graphCanvas" class="w-full h-full rounded-xl"></canvas>
        </div>
    </main>

    <!-- Sidebar -->
    <aside class="w-full md:w-72 lg:w-80 bg-white p-4 md:p-6 border-l border-gray-200 shadow-md flex flex-col overflow-y-auto">
        
        <!-- Language Toggle -->
        <div class="flex justify-end mb-4">
            <button id="lang-toggle" class="px-3 py-1 text-sm font-semibold text-gray-600 bg-gray-200 rounded-md hover:bg-gray-300 transition-colors"></button>
        </div>

        <!-- Stats -->
        <div class="space-y-4 mb-6">
            <div id="stats-vertices" class="stat-card bg-blue-500 text-white p-4 rounded-lg shadow-md" data-tooltip-key="tooltipVertices">
                <h2 id="h2-vertices" class="text-lg font-semibold">Vertices (V)</h2>
                <p id="vertices-count" class="text-3xl font-bold">0</p>
            </div>
            <div id="stats-edges" class="stat-card bg-green-500 text-white p-4 rounded-lg shadow-md" data-tooltip-key="tooltipEdges">
                <h2 id="h2-edges" class="text-lg font-semibold">Edges (E)</h2>
                <p id="edges-count" class="text-3xl font-bold">0</p>
            </div>
            <div id="stats-faces" class="stat-card bg-purple-500 text-white p-4 rounded-lg shadow-md" data-tooltip-key="tooltipFaces">
                <h2 id="h2-faces" class="text-lg font-semibold">Faces (F)</h2>
                <p id="faces-count" class="text-3xl font-bold">1</p>
            </div>
            <div id="stats-components" class="stat-card bg-orange-500 text-white p-4 rounded-lg shadow-md" data-tooltip-key="tooltipComponents">
                <h2 id="h2-components" class="text-lg font-semibold">Components (C)</h2>
                <p id="components-count" class="text-3xl font-bold">0</p>
            </div>
        </div>

        <!-- Euler's Formula Tracker -->
        <div id="euler-tracker" class="bg-gray-100 p-4 rounded-lg border-2 border-green-400 text-center mb-6 transition-colors duration-300">
            <h3 id="h3-euler" class="font-semibold text-gray-800 mb-2">Euler Characteristic</h3>
            <div class="text-lg font-mono font-bold text-gray-700 flex justify-center items-center space-x-2">
                <span>(<span id="euler-v" class="text-blue-500">0</span> - <span id="euler-e" class="text-green-500">0</span> + <span id="euler-f" class="text-purple-500">1</span>)</span>
                <span id="euler-equals" class="text-green-600 font-bold text-xl">=</span>
                <span>(<span id="euler-c" class="text-orange-500">0</span> + 1)</span>
            </div>
            <p id="p-euler-formula" class="text-xs text-gray-500 mt-1">V - E + F = C + 1</p>
        </div>
        
        <!-- Controls -->
        <div class="bg-gray-50 p-4 rounded-lg border border-gray-200 mb-6">
             <!-- Coloring Toggle -->
            <div class="flex items-center justify-between mb-4" data-tooltip-key="tooltipColoring">
                <label id="label-coloring" for="coloringToggle" class="font-semibold text-gray-700">Coloring Mode</label>
                <div class="relative inline-block w-10 mr-2 align-middle select-none transition duration-200 ease-in">
                    <input type="checkbox" name="coloringToggle" id="coloringToggle" class="toggle-checkbox absolute block w-6 h-6 rounded-full bg-white border-4 appearance-none cursor-pointer"/>
                    <label for="coloringToggle" class="toggle-label block overflow-hidden h-6 rounded-full bg-gray-300 cursor-pointer"></label>
                </div>
            </div>
            <!-- Validate Coloring Toggle -->
            <div class="flex items-center justify-between mb-4" data-tooltip-key="tooltipValidate">
                <label id="label-validate" for="validateColoringToggle" class="font-semibold text-gray-700">Validate Coloring</label>
                <div class="relative inline-block w-10 mr-2 align-middle select-none transition duration-200 ease-in">
                    <input type="checkbox" name="validateColoringToggle" id="validateColoringToggle" class="toggle-checkbox absolute block w-6 h-6 rounded-full bg-white border-4 appearance-none cursor-pointer"/>
                    <label for="validateColoringToggle" class="toggle-label block overflow-hidden h-6 rounded-full bg-gray-300 cursor-pointer"></label>
                </div>
            </div>
            <!-- Number of Colors Dropdown -->
            <div id="numColorsContainer" class="hidden">
                <label id="label-num-colors" for="numColorsSelect" class="block text-sm font-medium text-gray-700 mb-1">Number of Colors</label>
                <select id="numColorsSelect" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md">
                    <option>1</option>
                    <option>2</option>
                    <option selected>3</option>
                    <option>4</option>
                    <option>5</option>
                    <option>6</option>
                </select>
            </div>
        </div>


        <!-- Load Image Button -->
        <div class="mb-6">
            <label id="label-load-image" for="imageLoader" class="w-full inline-block text-center bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg cursor-pointer transition-colors duration-300" data-tooltip-key="tooltipLoadImage">
                Load Background Image
            </label>
            <input type="file" id="imageLoader" class="hidden" accept="image/*">
        </div>

        <!-- Instructions -->
        <div class="bg-gray-50 p-4 rounded-lg border border-gray-200 mt-auto">
            <h3 id="h3-how-to-use" class="font-semibold text-gray-700 mb-2">How to Use:</h3>
            <ul class="list-disc list-inside text-sm text-gray-600 space-y-1">
                <li id="li-left-click"></li>
                <li id="li-right-click"></li>
                <li id="li-drag"></li>
                <li id="li-color-vertex"></li>
            </ul>
        </div>
    </aside>

    <!-- Tooltip Element -->
    <div id="tooltip" class="hidden absolute bg-gray-800 text-white text-sm rounded-md px-3 py-1 shadow-lg"></div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('graphCanvas');
            const ctx = canvas.getContext('2d');
            const imageLoader = document.getElementById('imageLoader');
            const coloringToggle = document.getElementById('coloringToggle');
            const validateColoringToggle = document.getElementById('validateColoringToggle');
            const numColorsContainer = document.getElementById('numColorsContainer');
            const numColorsSelect = document.getElementById('numColorsSelect');
            const langToggle = document.getElementById('lang-toggle');
            const tooltip = document.getElementById('tooltip');
            
            const statPanels = {
                vertices: document.getElementById('stats-vertices'),
                edges: document.getElementById('stats-edges'),
                faces: document.getElementById('stats-faces'),
                components: document.getElementById('stats-components'),
            };

            // --- State ---
            let vertices = [];
            let edges = [];
            let selectedVertex = null;
            let draggingVertex = null;
            let draggingEdge = null;
            let potentialEdge = null;
            let nextVertexId = 0;
            let nextEdgeId = 0;
            let backgroundImage = null;
            let coloringMode = false;
            let validateColoringMode = false;
            let numColors = 3;
            let dragStartX = 0; 
            let dragStartY = 0; 
            let highlightMode = 'none'; // 'none', 'vertices', 'edges', 'faces', 'components'
            let currentLang = 'en';
            let hoverTimeout = null;
            let needsRedraw = true;
            const vertexRadius = 15;
            const edgeHitboxWidth = 6;
            const colorPalette = ['#3b82f6', '#ef4444', '#22c55e', '#f97316', '#8b5cf6', '#eab308']; // Blue, Red, Green, Orange, Purple, Yellow
            const componentColors = ['#16a34a', '#dc2626', '#d97706', '#9333ea', '#0284c7', '#db2777'];
            const faceHighlightColors = ['rgba(22, 163, 74, 0.4)', 'rgba(220, 38, 38, 0.4)', 'rgba(217, 119, 6, 0.4)', 'rgba(147, 51, 234, 0.4)', 'rgba(2, 132, 199, 0.4)', 'rgba(219, 39, 119, 0.4)'];
            const highlightColor = '#000000';
            const mutedColor = '#e5e7eb'; // gray-200

            const translations = {
                en: {
                    vertices: "Vertices (V)", edges: "Edges (E)", faces: "Faces (F)", components: "Components (C)",
                    eulerTitle: "Euler Characteristic", eulerFormula: "V - E + F = C + 1",
                    coloringMode: "Coloring Mode", validateColoring: "Validate Coloring", numColors: "Number of Colors",
                    loadImage: "Load Background Image", howToUse: "How to Use:",
                    instLeftClick: "Left Click: Add vertex (on space), or select/connect vertices.",
                    instRightClick: "Right Click: Delete element, or straighten a curved edge.",
                    instDrag: "Drag: Move a vertex, or curve an edge.",
                    instColorVertex: "Color Vertex: Toggle coloring mode and click a vertex.",
                    tooltipVertices: "Click to highlight all vertices.", tooltipEdges: "Click to highlight all edges.",
                    tooltipFaces: "Click to color the graph's faces.", tooltipComponents: "Click to highlight connected components.",
                    tooltipColoring: "Enable to color vertices by clicking them.", tooltipValidate: "Highlight edges between same-colored vertices.",
                    tooltipLoadImage: "Select an image to use as the canvas background.", tooltipLang: "Switch language between English and Japanese."
                },
                ja: {
                    vertices: "頂点 (V)", edges: "辺 (E)", faces: "面 (F)", components: "連結成分 (C)",
                    eulerTitle: "オイラー標数", eulerFormula: "V - E + F = C + 1",
                    coloringMode: "彩色モード", validateColoring: "彩色を検証", numColors: "色の数",
                    loadImage: "背景画像を読み込む", howToUse: "使い方:",
                    instLeftClick: "左クリック: 頂点の追加 (空白)、頂点の選択/接続",
                    instRightClick: "右クリック: 要素の削除、または曲がった辺を直線に",
                    instDrag: "ドラッグ: 頂点の移動、または辺を曲げる",
                    instColorVertex: "頂点の彩色: 彩色モードで頂点をクリック",
                    tooltipVertices: "クリックして、すべての頂点をハイライトします。", tooltipEdges: "クリックして、すべての辺をハイライトします。",
                    tooltipFaces: "クリックして、グラフの面を色付けします。", tooltipComponents: "クリックして、連結成分をハイライトします。",
                    tooltipColoring: "有効にすると、クリックで頂点を彩色できます。", tooltipValidate: "同じ色の頂点間の辺をハイライトします。",
                    tooltipLoadImage: "キャンバスの背景として使用する画像を選択します。", tooltipLang: "言語を英語と日本語で切り替えます。"
                }
            };

            // --- Language Function ---
            function setLanguage(lang) {
                const t = translations[lang];
                document.getElementById('h2-vertices').textContent = t.vertices;
                document.getElementById('h2-edges').textContent = t.edges;
                document.getElementById('h2-faces').textContent = t.faces;
                document.getElementById('h2-components').textContent = t.components;
                document.getElementById('h3-euler').textContent = t.eulerTitle;
                document.getElementById('p-euler-formula').textContent = t.eulerFormula;
                document.getElementById('label-coloring').textContent = t.coloringMode;
                document.getElementById('label-validate').textContent = t.validateColoring;
                document.getElementById('label-num-colors').textContent = t.numColors;
                document.getElementById('label-load-image').textContent = t.loadImage;
                document.getElementById('h3-how-to-use').textContent = t.howToUse;
                document.getElementById('li-left-click').textContent = t.instLeftClick;
                document.getElementById('li-right-click').textContent = t.instRightClick;
                document.getElementById('li-drag').textContent = t.instDrag;
                document.getElementById('li-color-vertex').textContent = t.instColorVertex;
                
                langToggle.innerHTML = (lang === 'ja') ? 'EN / <span class="font-bold">JA</span>' : '<span class="font-bold">EN</span> / JA';
            }


            // --- Resize Handling ---
            function resizeCanvas() {
                const dpr = window.devicePixelRatio || 1;
                const rect = canvas.getBoundingClientRect();
                canvas.width = rect.width * dpr;
                canvas.height = rect.height * dpr;
                ctx.scale(dpr, dpr);
                needsRedraw = true;
            }

            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();

            // --- HIGHLIGHTING LOGIC ---
            function drawMutedGraph() {
                ctx.strokeStyle = mutedColor;
                ctx.lineWidth = 3;
                edges.forEach(edge => {
                    const v1 = vertices.find(v => v.id === edge.v1);
                    const v2 = vertices.find(v => v.id === edge.v2);
                    if (v1 && v2) {
                        ctx.beginPath();
                        ctx.moveTo(v1.x, v1.y);
                        if(edge.cp1x) {
                            ctx.quadraticCurveTo(edge.cp1x, edge.cp1y, v2.x, v2.y);
                        } else {
                            ctx.lineTo(v2.x, v2.y);
                        }
                        ctx.stroke();
                    }
                });
                ctx.fillStyle = mutedColor;
                vertices.forEach(vertex => {
                    ctx.beginPath();
                    ctx.arc(vertex.x, vertex.y, vertexRadius, 0, 2 * Math.PI);
                    ctx.fill();
                });
            }

            function drawFacesHighlight() {
                drawMutedGraph();
                const faces = findAllFacesGeometric();
                const vertexMap = new Map(vertices.map(v => [v.id, v]));

                faces.forEach((faceCycle, i) => {
                    const cycleVertices = faceCycle.map(id => vertexMap.get(id));
                    if (cycleVertices.length < 3 || cycleVertices.some(v => v === undefined)) return;

                    ctx.beginPath();
                    ctx.moveTo(cycleVertices[0].x, cycleVertices[0].y);
                    for (let j = 1; j < cycleVertices.length; j++) {
                        ctx.lineTo(cycleVertices[j].x, cycleVertices[j].y);
                    }
                    ctx.closePath();
                    
                    ctx.fillStyle = faceHighlightColors[i % faceHighlightColors.length];
                    ctx.fill();
                });
            }
            
            function drawComponentsHighlight() {
                drawMutedGraph();
                const { components } = findConnectedComponents();
                components.forEach((component, i) => {
                    const componentColor = componentColors[i % componentColors.length];
                    ctx.strokeStyle = componentColor;
                    ctx.fillStyle = componentColor;
                    ctx.lineWidth = 3;

                    const componentVertices = new Set(component);
                    const componentEdges = edges.filter(e => componentVertices.has(e.v1) && componentVertices.has(e.v2));
                    
                    componentEdges.forEach(edge => {
                        const v1 = vertices.find(v => v.id === edge.v1);
                        const v2 = vertices.find(v => v.id === edge.v2);
                        if(v1 && v2) {
                            ctx.beginPath();
                            ctx.moveTo(v1.x, v1.y);
                            if(edge.cp1x) {
                                ctx.quadraticCurveTo(edge.cp1x, edge.cp1y, v2.x, v2.y);
                            } else {
                                ctx.lineTo(v2.x, v2.y);
                            }
                            ctx.stroke();
                        }
                    });
                    
                    component.forEach(vertexId => {
                        const vertex = vertices.find(v => v.id === vertexId);
                        if (vertex) {
                            ctx.beginPath();
                            ctx.arc(vertex.x, vertex.y, vertexRadius, 0, 2 * Math.PI);
                            ctx.fill();
                        }
                    });
                });
            }

            // --- Drawing Functions ---
            function draw() {
                const rect = canvas.getBoundingClientRect();
                ctx.clearRect(0, 0, rect.width, rect.height);

                if (backgroundImage) {
                    ctx.drawImage(backgroundImage, 0, 0, rect.width, rect.height);
                }

                if (highlightMode === 'faces') {
                    drawFacesHighlight();
                    return;
                }
                if (highlightMode === 'components') {
                    drawComponentsHighlight();
                    return;
                }
                
                if (potentialEdge) {
                    ctx.beginPath();
                    ctx.moveTo(potentialEdge.v1.x, potentialEdge.v1.y);
                    ctx.lineTo(potentialEdge.v2.x, potentialEdge.v2.y);
                    ctx.strokeStyle = mutedColor;
                    ctx.lineWidth = 3;
                    ctx.setLineDash([5, 5]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }

                edges.forEach(edge => {
                    const v1 = vertices.find(v => v.id === edge.v1);
                    const v2 = vertices.find(v => v.id === edge.v2);
                    if (v1 && v2) {
                        ctx.beginPath();
                        ctx.moveTo(v1.x, v1.y);

                        if (validateColoringMode && v1.colorIndex === v2.colorIndex) {
                            ctx.strokeStyle = '#fef08a';
                            ctx.lineWidth = 5;
                        } else {
                            ctx.strokeStyle = (highlightMode === 'edges') ? highlightColor : '#60a5fa';
                            ctx.lineWidth = 3;
                        }
                        if (highlightMode === 'vertices') {
                            ctx.strokeStyle = mutedColor;
                        }

                        if (edge.cp1x && edge.cp1y) {
                            ctx.quadraticCurveTo(edge.cp1x, edge.cp1y, v2.x, v2.y);
                        } else {
                            ctx.lineTo(v2.x, v2.y);
                        }
                        ctx.stroke();
                    }
                });

                vertices.forEach(vertex => {
                    ctx.beginPath();
                    ctx.arc(vertex.x, vertex.y, vertexRadius, 0, 2 * Math.PI);
                    
                    let vertexColor = colorPalette[vertex.colorIndex % numColors];
                    if (!coloringMode && selectedVertex && selectedVertex.id === vertex.id) {
                        vertexColor = '#ef4444';
                    }
                    
                    ctx.fillStyle = (highlightMode === 'vertices') ? highlightColor : vertexColor;
                    if (highlightMode === 'edges') {
                        ctx.fillStyle = mutedColor;
                    }
                    ctx.fill();
                    
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                });
            }

            // --- Graph Logic ---
            function addVertex(x, y) {
                vertices.push({ id: nextVertexId++, x, y, colorIndex: 0 });
                updateStats();
            }

            function addEdge(v1_id, v2_id) {
                if (v1_id === v2_id) return;
                const exists = edges.some(edge => 
                    (edge.v1 === v1_id && edge.v2 === v2_id) || (edge.v1 === v2_id && edge.v2 === v1_id)
                );
                if (!exists) {
                    edges.push({ id: nextEdgeId++, v1: v1_id, v2: v2_id, cp1x: null, cp1y: null });
                    updateStats();
                }
            }
            
            function removeVertex(vertexId) {
                vertices = vertices.filter(v => v.id !== vertexId);
                edges = edges.filter(e => e.v1 !== vertexId && e.v2 !== vertexId);
                if (selectedVertex && selectedVertex.id === vertexId) {
                    selectedVertex = null;
                }
                updateStats();
            }

            function removeEdge(edgeId) {
                edges = edges.filter(e => e.id !== edgeId);
                updateStats();
            }

            // --- Utility Functions ---
            function getVertexAt(x, y) {
                for (let i = vertices.length - 1; i >= 0; i--) {
                    const vertex = vertices[i];
                    const dx = x - vertex.x;
                    const dy = y - vertex.y;
                    if (dx * dx + dy * dy < vertexRadius * vertexRadius) {
                        return vertex;
                    }
                }
                return null;
            }

            function getEdgeAt(x, y) {
                for (const edge of edges) {
                    const v1 = vertices.find(v => v.id === edge.v1);
                    const v2 = vertices.find(v => v.id === edge.v2);
                    if (!v1 || !v2) continue;

                    if (edge.cp1x && edge.cp1y) { // Curved edge hit detection
                        const p0 = { x: v1.x, y: v1.y };
                        const p1 = { x: edge.cp1x, y: edge.cp1y };
                        const p2 = { x: v2.x, y: v2.y };
                        const steps = 10;
                        let lastPoint = p0;

                        for (let i = 1; i <= steps; i++) {
                            const t = i / steps;
                            const currentPoint = {
                                x: (1 - t) * (1 - t) * p0.x + 2 * (1 - t) * t * p1.x + t * t * p2.x,
                                y: (1 - t) * (1 - t) * p0.y + 2 * (1 - t) * t * p1.y + t * t * p2.y
                            };
                            
                            const dx_seg = currentPoint.x - lastPoint.x;
                            const dy_seg = currentPoint.y - lastPoint.y;
                            const lenSq_seg = dx_seg * dx_seg + dy_seg * dy_seg;
                            if(lenSq_seg === 0) continue;

                            let t_seg = ((x - lastPoint.x) * dx_seg + (y - lastPoint.y) * dy_seg) / lenSq_seg;
                            t_seg = Math.max(0, Math.min(1, t_seg));

                            const closestX = lastPoint.x + t_seg * dx_seg;
                            const closestY = lastPoint.y + t_seg * dy_seg;
                            const distSq = (x - closestX)**2 + (y - closestY)**2;

                            if (distSq < edgeHitboxWidth * edgeHitboxWidth) return edge;
                            
                            lastPoint = currentPoint;
                        }
                    } else { // Straight edge hit detection
                        const dx = v2.x - v1.x;
                        const dy = v2.y - v1.y;
                        const lenSq = dx * dx + dy * dy;
                        if (lenSq === 0) continue;

                        let t = ((x - v1.x) * dx + (y - v1.y) * dy) / lenSq;
                        t = Math.max(0, Math.min(1, t));

                        const closestX = v1.x + t * dx;
                        const closestY = v1.y + t * dy;
                        const distSq = (x - closestX)**2 + (y - closestY)**2;

                        if (distSq < edgeHitboxWidth * edgeHitboxWidth) return edge;
                    }
                }
                return null;
            }
            
            function findConnectedComponents() {
                const visited = new Set();
                const components = [];
                if (vertices.length > 0) {
                    const adj = new Map();
                    vertices.forEach(v => adj.set(v.id, []));
                    edges.forEach(e => {
                        adj.get(e.v1).push(e.v2);
                        adj.get(e.v2).push(e.v1);
                    });

                    vertices.forEach(vertex => {
                        if (!visited.has(vertex.id)) {
                            const currentComponent = [];
                            const queue = [vertex.id];
                            visited.add(vertex.id);
                            while (queue.length > 0) {
                                const u = queue.shift();
                                currentComponent.push(u);
                                adj.get(u).forEach(v_id => {
                                    if (!visited.has(v_id)) {
                                        visited.add(v_id);
                                        queue.push(v_id);
                                    }
                                });
                            }
                            components.push(currentComponent);
                        }
                    });
                }
                return { components, count: components.length };
            }
            
            function findAllFacesGeometric() {
                if (vertices.length < 3) return [];

                const adj = new Map();
                const vertexMap = new Map(vertices.map(v => [v.id, v]));

                vertices.forEach(v => {
                    const neighbors = [];
                    edges.forEach(e => {
                        if (e.v1 === v.id) neighbors.push(vertexMap.get(e.v2));
                        else if (e.v2 === v.id) neighbors.push(vertexMap.get(e.v1));
                    });

                    neighbors.sort((a, b) => {
                        const angleA = Math.atan2(a.y - v.y, a.x - v.x);
                        const angleB = Math.atan2(b.y - v.y, b.x - v.x);
                        return angleA - angleB;
                    });
                    
                    adj.set(v.id, neighbors.map(n => n.id));
                });

                const visitedEdges = new Set();
                const faces = [];

                for (const edge of edges) {
                    const edgeId1 = `${edge.v1}-${edge.v2}`;
                    if (!visitedEdges.has(edgeId1)) {
                        faces.push(traceFace(edge.v1, edge.v2));
                    }
                    const edgeId2 = `${edge.v2}-${edge.v1}`;
                     if (!visitedEdges.has(edgeId2)) {
                        faces.push(traceFace(edge.v2, edge.v1));
                    }
                }
                
                function traceFace(startNodeId, secondNodeId) {
                    const face = [startNodeId];
                    let prevNodeId = startNodeId;
                    let currNodeId = secondNodeId;

                    while(currNodeId !== startNodeId) {
                        face.push(currNodeId);
                        const edgeId = `${prevNodeId}-${currNodeId}`;
                        visitedEdges.add(edgeId);

                        const neighbors = adj.get(currNodeId);
                        const prevIndex = neighbors.indexOf(prevNodeId);
                        const nextIndex = (prevIndex + 1) % neighbors.length;
                        
                        const nextNodeId = neighbors[nextIndex];
                        prevNodeId = currNodeId;
                        currNodeId = nextNodeId;

                        if (face.length > vertices.length) return [];
                    }
                    return face;
                }

                if (faces.length <= 1) return faces;
                
                let outerFaceIndex = -1;
                let maxArea = -1;

                faces.forEach((face, i) => {
                    let area = 0;
                    const cycleVertices = face.map(id => vertexMap.get(id));
                    for (let j = 0; j < cycleVertices.length; j++) {
                        const v1 = cycleVertices[j];
                        const v2 = cycleVertices[(j + 1) % cycleVertices.length];
                        area += (v1.x * v2.y - v2.x * v1.y);
                    }
                    area = Math.abs(area / 2);
                    
                    if (area > maxArea) {
                        maxArea = area;
                        outerFaceIndex = i;
                    }
                });

                return faces.filter((_, i) => i !== outerFaceIndex);
            }


            // --- Stats Calculation ---
            function updateStats() {
                const V = vertices.length;
                const E = edges.length;
                const { count: C } = findConnectedComponents();
                const F = (V === 0) ? 1 : (E - V + C + 1);
                
                document.getElementById('vertices-count').textContent = V;
                document.getElementById('edges-count').textContent = E;
                document.getElementById('faces-count').textContent = F;
                document.getElementById('components-count').textContent = C;

                document.getElementById('euler-v').textContent = V;
                document.getElementById('euler-e').textContent = E;
                document.getElementById('euler-f').textContent = F;
                document.getElementById('euler-c').textContent = C;

                const lhs = V - E + F;
                const rhs = C + 1;
                const eulerTrackerDiv = document.getElementById('euler-tracker');
                const eulerEquals = document.getElementById('euler-equals');
                if (lhs === rhs) {
                    eulerTrackerDiv.classList.remove('border-red-400');
                    eulerTrackerDiv.classList.add('border-green-400');
                    eulerEquals.classList.remove('text-red-600');
                    eulerEquals.classList.add('text-green-600');
                    eulerEquals.textContent = "=";
                } else {
                    eulerTrackerDiv.classList.add('border-red-400');
                    eulerTrackerDiv.classList.remove('border-green-400');
                    eulerEquals.classList.add('text-red-600');
                    eulerEquals.classList.remove('text-green-600');
                    eulerEquals.textContent = "≠";
                }

                needsRedraw = true;
            }

            // --- Event Listeners ---
            function getMousePos(evt) {
                const rect = canvas.getBoundingClientRect();
                const clientX = evt.clientX ?? evt.touches[0].clientX;
                const clientY = evt.clientY ?? evt.touches[0].clientY;
                return { x: clientX - rect.left, y: clientY - rect.top };
            }
            
            function addTooltip(element) {
                const tooltipKey = element.dataset.tooltipKey;
                if (!tooltipKey) return;

                element.addEventListener('mouseenter', (e) => {
                    clearTimeout(hoverTimeout);
                    hoverTimeout = setTimeout(() => {
                        tooltip.textContent = translations[currentLang][tooltipKey];
                        tooltip.style.left = `${e.pageX + 15}px`;
                        tooltip.style.top = `${e.pageY}px`;
                        tooltip.classList.remove('hidden');
                    }, 1000);
                });

                element.addEventListener('mouseleave', () => {
                    clearTimeout(hoverTimeout);
                    tooltip.classList.add('hidden');
                });
            }

            // Attach tooltips
            Object.values(statPanels).forEach(addTooltip);
            langToggle.dataset.tooltipKey = 'tooltipLang';
            addTooltip(langToggle);
            document.querySelector('[for="imageLoader"]').dataset.tooltipKey = 'tooltipLoadImage';
            addTooltip(document.querySelector('[for="imageLoader"]'));
            document.querySelector('[for="coloringToggle"]').parentElement.dataset.tooltipKey = 'tooltipColoring';
            addTooltip(document.querySelector('[for="coloringToggle"]').parentElement);
            document.querySelector('[for="validateColoringToggle"]').parentElement.dataset.tooltipKey = 'tooltipValidate';
            addTooltip(document.querySelector('[for="validateColoringToggle"]').parentElement);


            Object.entries(statPanels).forEach(([mode, panel]) => {
                panel.addEventListener('click', () => {
                    highlightMode = highlightMode === mode ? 'none' : mode;
                    Object.values(statPanels).forEach(p => p.classList.remove('active'));
                    if (highlightMode !== 'none') {
                        panel.classList.add('active');
                    }
                    needsRedraw = true;
                });
            });

            langToggle.addEventListener('click', () => {
                currentLang = currentLang === 'en' ? 'ja' : 'en';
                setLanguage(currentLang);
            });

            coloringToggle.addEventListener('change', (e) => {
                coloringMode = e.target.checked;
                if (coloringMode) {
                    numColorsContainer.classList.remove('hidden');
                    selectedVertex = null;
                } else {
                    numColorsContainer.classList.add('hidden');
                }
                needsRedraw = true;
            });
            
            validateColoringToggle.addEventListener('change', (e) => {
                validateColoringMode = e.target.checked;
                needsRedraw = true;
            });

            numColorsSelect.addEventListener('change', (e) => {
                numColors = parseInt(e.target.value, 10);
                vertices.forEach(v => { if (v.colorIndex >= numColors) v.colorIndex = 0; });
                needsRedraw = true;
            });

            imageLoader.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        const img = new Image();
                        img.onload = () => { backgroundImage = img; needsRedraw = true; };
                        img.src = event.target.result;
                    };
                    reader.readAsDataURL(file);
                }
            });

            canvas.addEventListener('mousedown', (e) => {
                if (e.button !== 0) return;
                e.preventDefault();
                const pos = getMousePos(e);
                const clickedVertex = getVertexAt(pos.x, pos.y);
                if (clickedVertex) {
                    draggingVertex = clickedVertex;
                    dragStartX = clickedVertex.x;
                    dragStartY = clickedVertex.y;
                    return;
                }

                const clickedEdge = getEdgeAt(pos.x, pos.y);
                if(clickedEdge) {
                    draggingEdge = clickedEdge;
                    if (!draggingEdge.cp1x) { // Initialize control point at midpoint if it doesn't exist
                        const v1 = vertices.find(v => v.id === draggingEdge.v1);
                        const v2 = vertices.find(v => v.id === draggingEdge.v2);
                        draggingEdge.cp1x = (v1.x + v2.x) / 2;
                        draggingEdge.cp1y = (v1.y + v2.y) / 2;
                    }
                }
            });

            canvas.addEventListener('mousemove', (e) => {
                e.preventDefault();
                const pos = getMousePos(e);
                if (draggingVertex) {
                    draggingVertex.x = pos.x;
                    draggingVertex.y = pos.y;
                    needsRedraw = true;
                    return;
                }
                if (draggingEdge) {
                    draggingEdge.cp1x = pos.x;
                    draggingEdge.cp1y = pos.y;
                    needsRedraw = true;
                    return;
                }
                
                let newPotentialEdge = null;

                if (!selectedVertex && !coloringMode) {
                    for (let i = 0; i < vertices.length; i++) {
                        for (let j = i + 1; j < vertices.length; j++) {
                            const v1 = vertices[i];
                            const v2 = vertices[j];
                            
                            const edgeExists = edges.some(edge => (edge.v1 === v1.id && edge.v2 === v2.id) || (edge.v1 === v2.id && edge.v2 === v1.id));
                            if (edgeExists) continue;

                            const dx = v2.x - v1.x;
                            const dy = v2.y - v1.y;
                            const lenSq = dx * dx + dy * dy;

                            if (lenSq === 0) continue;

                            let t = ((pos.x - v1.x) * dx + (pos.y - v1.y) * dy) / lenSq;
                            t = Math.max(0, Math.min(1, t));

                            const closestX = v1.x + t * dx;
                            const closestY = v1.y + t * dy;

                            const distSq = (pos.x - closestX) * (pos.x - closestX) + (pos.y - closestY) * (pos.y - closestY);

                            if (distSq < edgeHitboxWidth * edgeHitboxWidth) {
                                newPotentialEdge = { v1, v2 };
                                break;
                            }
                        }
                        if (newPotentialEdge) break;
                    }
                }
                
                if (potentialEdge?.v1?.id !== newPotentialEdge?.v1?.id || potentialEdge?.v2?.id !== newPotentialEdge?.v2?.id) {
                    potentialEdge = newPotentialEdge;
                    needsRedraw = true;
                }
            });

            canvas.addEventListener('mouseup', (e) => {
                if (e.button !== 0) return;
                e.preventDefault();

                if (draggingEdge) {
                    draggingEdge = null;
                    updateStats();
                    return;
                }

                let wasDrag = false;
                if (draggingVertex) {
                    const distSq = (draggingVertex.x - dragStartX)**2 + (draggingVertex.y - dragStartY)**2;
                    if (distSq > 4) wasDrag = true;
                }

                if (wasDrag) {
                    draggingVertex = null;
                    updateStats();
                    return;
                }
                
                if (potentialEdge) {
                    addEdge(potentialEdge.v1.id, potentialEdge.v2.id);
                    potentialEdge = null;
                    draggingVertex = null;
                    updateStats();
                    return;
                }

                const pos = getMousePos(e);
                const clickedVertex = getVertexAt(pos.x, pos.y);

                if (coloringMode) {
                    if (clickedVertex) {
                        clickedVertex.colorIndex = (clickedVertex.colorIndex + 1) % numColors;
                    }
                } else {
                    if (clickedVertex) {
                        if (!selectedVertex) {
                            selectedVertex = clickedVertex;
                        } else {
                            if (selectedVertex.id === clickedVertex.id) {
                                selectedVertex = null; // Click same vertex to deselect
                            } else {
                                addEdge(selectedVertex.id, clickedVertex.id);
                                selectedVertex = null;
                            }
                        }
                    } else {
                        addVertex(pos.x, pos.y); // Always add vertex on empty space
                        selectedVertex = null;
                    }
                }
                
                draggingVertex = null;
                updateStats(); 
            });

            canvas.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                potentialEdge = null;
                const pos = getMousePos(e);
                const clickedVertex = getVertexAt(pos.x, pos.y);
                if (clickedVertex) {
                    removeVertex(clickedVertex.id);
                    return;
                }
                
                const clickedEdge = getEdgeAt(pos.x, pos.y);
                if (clickedEdge) {
                    if (clickedEdge.cp1x) { // If it's a curved edge, straighten it
                        clickedEdge.cp1x = null;
                        clickedEdge.cp1y = null;
                    } else { // If it's a straight edge, delete it
                        removeEdge(clickedEdge.id);
                    }
                    updateStats();
                    return;
                }
            });

            // Animation Loop
            function animationLoop() {
                if (needsRedraw) {
                    draw();
                    needsRedraw = false;
                }
                requestAnimationFrame(animationLoop);
            }

            // Initial setup
            setLanguage(currentLang);
            updateStats();
            animationLoop();
        });
    </script>
</body>
</html>
